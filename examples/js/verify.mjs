import { readFileSync } from "fs";
import { Veritas, QueryContext } from "./pkg/libveritas.js";

// Load fixtures generated by `cargo run --bin generate-fixture`
const anchors = JSON.parse(readFileSync("examples/fixture/anchors.json", "utf8"));
const msg = readFileSync("examples/fixture/message.bin");

// Create verifier
const veritas = new Veritas(anchors);
veritas.set_dev_mode(true);
console.log(`anchors: ${veritas.oldest_anchor()} .. ${veritas.newest_anchor()}`);

// Build query context (empty = verify all handles)
const ctx = new QueryContext();

// Verify message
const result = veritas.verify_message(ctx, msg);

// Zones (now proper objects with methods)
const zones = result.zones();
console.log(`\n${zones.length} zones verified:`);
for (const z of zones) {
  console.log(`  ${z.handle()} -> ${z.sovereignty()} (anchor ${z.anchor()})`);
}

// Compare zones
if (zones.length >= 2) {
  const a = zones[0];
  const b = zones[1];
  // These are different handles so is_better_than will error — just showing the API exists
  try {
    console.log(`\n${a.handle()} better than ${b.handle()}? ${a.is_better_than(b)}`);
  } catch (e) {
    console.log(`\nis_better_than(${a.handle()}, ${b.handle()}): ${e.message} (expected — different handles)`);
  }
}

// Zone bytes for storage
const sovereignBytes = zones[0].to_bytes();
console.log(`\n@sovereign zone bytes: ${sovereignBytes.length} bytes`);

// Zone as JS object
const sovereignObj = zones[0].to_json();
console.log(`@sovereign zone json keys: ${Object.keys(sovereignObj).join(", ")}`);

// Certificates
const certs = result.certificates();
console.log(`\n${certs.length} certificates:`);
for (const c of certs) {
  console.log(`  ${c.subject} [${c.witness === "Root" || c.witness?.Root ? "root" : "leaf"}]`);
}

console.log("\ndone.");
